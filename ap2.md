The Architecture of Autonomous Value Transfer: Integrating Google Agentic Commerce with the MultiversX Sovereign Blockchain1. Executive SummaryThe digital economy is currently navigating a profound structural inflection point, transitioning from a user-centric interaction model—characterized by human-initiated clicks and manual authorizations—to an agent-centric paradigm. In this emerging "Agentic Economy," autonomous Artificial Intelligence (AI) agents serve as the primary economic actors, capable of negotiating, purchasing, and settling transactions on behalf of human principals without synchronous oversight. This shift necessitates a fundamental re-architecture of the internet’s payment rails, moving beyond the limitations of legacy APIs toward deterministic, cryptographically verifiable protocols.Google’s Agentic Commerce ecosystem, specifically the Agent Payments Protocol (AP2) and the Agent-to-Agent (A2A) x402 extension, provides the linguistic and procedural standardization required for this new economy.1 By defining rigorous "Mandates"—Verifiable Credentials (VCs) that encapsulate user intent—AP2 solves the principal-agent problem inherent in autonomous systems. However, while AP2 provides the authorization layer, it requires a high-throughput, low-latency settlement layer to finalize value transfer. MultiversX (formerly Elrond), with its Adaptive State Sharding and native Relayed Transactions V3, offers a compelling infrastructure for this purpose, particularly in its ability to abstract gas fees away from autonomous agents.3This report presents an exhaustive technical analysis and implementation roadmap for integrating AP2 and the x402 protocol with the MultiversX blockchain. It details the precise mapping of W3C Decentralized Identifiers (DIDs) to MultiversX addresses, the architectural implementation of the x402 "functional core" in Python, and the utilization of Relayed Transactions V3 to enable "Gasless Agentic Commerce." Furthermore, it outlines the governance pathway for achieving official integration status within the Google ecosystem, emphasizing strict adherence to Chain Agnostic Improvement Proposals (CAIPs) and open-source contribution standards. The synthesis of these technologies promises to create a robust, trustless environment where AI agents can operate with the legal and financial certainty required for enterprise-scale adoption.2. The Theoretical Framework of Agentic CommerceTo understand the necessity of the integration between Google’s protocols and MultiversX, one must first dissect the theoretical underpinnings of the Agentic Economy. Unlike traditional e-commerce, which relies on probabilistic conversion funnels, agentic commerce relies on deterministic execution of user intent.2.1 The Principal-Agent Problem in AIIn economic theory, the principal-agent problem arises when one person (the principal) allows another person (the agent) to act on their behalf, and the agent has incentives to act in their own best interest rather than the principal's. In the context of Generative AI, this risk is amplified by "hallucinations" or misaligned objective functions. An AI instructed to "buy the best shoes" might drain a user's bank account on luxury items if not constrained by rigorous, cryptographically enforcement bounds.5The industry's response, led by the Google Agentic Commerce organization, is to move trust from the model (which is probabilistic) to the protocol (which is deterministic). This is achieved through the Agent Payments Protocol (AP2), which introduces a "Chain of Trust" using Verifiable Credentials.2.2 The Convergence of Web3 and AIWhile AI provides the autonomy, Web3 technologies provide the immutable audit trails and value transfer mechanisms required to police that autonomy. The integration of AP2 with a blockchain like MultiversX is not merely a feature addition; it is a foundational requirement for "Accountable AI."Non-Repudiation: Blockchain transactions provide proof of payment that an AI agent cannot forge or delete.Smart Accounts: MultiversX’s account model allows for programmable logic (such as multi-signature requirements or spending limits) to be enforced at the protocol level, complementing the off-chain mandates of AP2.3. Deconstructing the Google Agentic Commerce StackThe Google Agentic Commerce stack is a modular suite of protocols designed to standardize how agents discover, negotiate, and pay for services. It is composed principally of the AP2 protocol for authorization and the x402 extension for payment execution.3.1 The Agent Payments Protocol (AP2)The AP2 repository serves as the backbone for secure AI-driven payments. Its primary purpose is to establish a secure and interoperable future for agent transactions by defining a standard for "Mandates".13.1.1 The Mandate ArchitectureAt the core of AP2 lies the concept of the Mandate. A Mandate is a specialized Verifiable Credential (VC) that creates a binding digital contract between the user, the agent, and the merchant. Unlike a simple API token, a Mandate is a cryptographically signed document that travels with the transaction request.2The protocol defines a tripartite state machine for these mandates:Intent Mandate: This is the genesis of the transaction. When a user issues a prompt (e.g., "Book a flight to London under $600"), the Shopping Agent (SA) generates an Intent Mandate. This VC captures the constraints of the delegation: maximum budget, category of purchase, and time-to-live (TTL).7 In the "Human-Not-Present" workflow, this mandate allows the agent to act autonomously as long as the merchant's offer falls within the signed constraints.5Cart Mandate: Once the Shopping Agent negotiates with a Merchant Agent (MA), a Cart Mandate is produced. This VC locks in the specific items, prices, and merchant identity. It references the original Intent Mandate, creating a lineage of authorization. The Cart Mandate must be signed, either by the user directly (in real-time scenarios) or derived from the Intent Mandate (in background scenarios).2Payment Mandate: The final step is the Payment Mandate. This VC instructs the Credentials Provider (CP) to release funds. It encapsulates the Cart Mandate and adds payment-specific details (payment method token, encrypted PAN, or in the case of Web3, the wallet signature). The PaymentMandate class, defined in src/ap2/types/mandate.py, is the critical interface for the MultiversX integration.5Table 1: The AP2 Mandate HierarchyMandate TypeFunctionSignerData PayloadIntentDelegation of AuthorityUser (Principal)Budget, Category, Expiry, User DIDCartItemization of AgreementMerchant & UserLine Items, Tax, Shipping, Intent RefPaymentExecution InstructionUser / AgentPayment Method, Cart Ref, Risk Signals3.1.2 Verifiable Credentials and DIDsAP2 leverages the W3C Verifiable Credentials Data Model 1.0. This ensures that mandates are interoperable across different systems. The actors in the system—User, Shopping Agent, Merchant Agent, and Credentials Provider—are identified using Decentralized Identifiers (DIDs).DID Methods: The protocol supports various DID methods like did:key (for ephemeral keys) and did:web (for domain-bound identity). For blockchain integration, did:pkh (Public Key Hashing) is the standard for representing on-chain accounts.10JSON-LD: Mandates are serialized using JSON-LD (JavaScript Object Notation for Linked Data), allowing for semantic annotation of the data fields.73.2 The A2A x402 ExtensionWhile AP2 handles the who and why (authorization), the a2a-x402 repository handles the how (payment execution). It revives the HTTP 402 "Payment Required" status code, applying it to the JSON-RPC messages exchanged between agents.13.2.1 The x402 Payment FlowThe extension defines a strict handshake protocol that any integration must follow:Payment Required: The Merchant Agent blocks a resource and sends a payment-required message. This message acts as an invoice, detailing the amount, currency (e.g., EGLD, USDC), and destination address.Payment Submitted: The Client Agent (or Credentials Provider) constructs the payment transaction, signs it, and returns the proof (transaction hash or signed payload) via a payment-submitted message.Payment Completed: The Merchant verifies the payment on the settlement layer (blockchain) and releases the resource via a payment-completed message.123.2.2 "Functional Core, Imperative Shell" ArchitectureA critical requirement for contributing to the a2a-x402 repository is adherence to the "functional core, imperative shell" design pattern.12Functional Core: This layer contains pure business logic. It takes inputs (e.g., payment amount, sender address) and returns outputs (e.g., a serialized unsigned transaction) without performing any side effects like network calls. This ensures that the code is deterministic and easily testable.Imperative Shell (Executors): This layer handles the "dirty" operations—broadcasting transactions to the network, querying APIs, and managing database state.Implication for Integration: When building the MultiversX scheme, the code that constructs the EGLD transaction must be completely isolated from the code that broadcasts it to the MultiversX Gateway.4. The MultiversX Settlement InfrastructureTo effectively integrate with Google's stack, one must utilize the specific features of the MultiversX blockchain that align with agentic workflows. MultiversX is a high-throughput, sharded blockchain that uses Secure Proof of Stake (SPoS). Its architecture offers distinct advantages over monolithic EVM chains for this specific use case.4.1 Relayed Transactions V3: The Agent EnablerThe most significant barrier to agentic commerce in Web3 is the "Gas Problem." If an AI agent creates a wallet to pay for services, that wallet must be funded with the native token (EGLD) to pay for gas fees. Managing gas balances across thousands of autonomous agents creates a massive treasury management burden and a security risk (hot wallets).MultiversX solves this natively through Relayed Transactions V3.3 This protocol feature allows a transaction to be signed by a sender (the User or Agent) but broadcast and paid for by a "Relayer" (the Credentials Provider).Mechanism: A Relayed V3 transaction encapsulates an inner transaction. It includes specific fields for Relayer (the address paying the fees) and RelayerSignature (proof of the relayer's consent).Cost Model: The gas cost is deterministic: GasLimit = 50,000 (base) + 50,000 (relayer base) + cost_per_byte * length(data).3Strategic Value: This allows the AP2 "Credentials Provider" to abstract the blockchain complexity entirely. The AI agent simply signs a "promise" to pay (the inner transaction), and the Credentials Provider handles the gas and broadcasting, effectively enabling "Gasless" commerce from the agent's perspective.34.2 Native Tokens (ESDT)Unlike Ethereum, where tokens are smart contracts (ERC-20), MultiversX uses ESDT (Elrond Standard Digital Token). Tokens are native protocol citizens associated directly with account storage.15Performance: Transferring ESDT is faster and cheaper than executing a smart contract call.Safety: The x402 implementation is safer because it doesn't need to interact with potentially malicious smart contracts to move funds; it relies on the protocol's native ESDTTransfer function.Data Field: An ESDT transfer is defined purely in the transaction's data field (e.g., ESDTTransfer@<TokenID>@<Amount>), making parsing and verification by Merchant Agents straightforward.164.3 Identity Standards: CAIPs and DIDsFor the Google Agentic Commerce ecosystem to recognize MultiversX accounts, they must be compliant with Chain Agnostic Improvement Proposals (CAIPs).CAIP-2 (Chain ID): This standard defines how to identify a blockchain. The MultiversX namespace is defined as mvx. The mainnet identifier is mvx:1.17CAIP-10 (Account ID): This standard defines how to identify a specific account on a specific chain. A MultiversX address erd1... is represented as mvx:1:erd1....18DID Method (did:pkh): The did:pkh (Public Key Hashing) method wraps CAIP-10 identifiers into a W3C DID. This is the format required by AP2 Mandates. A User's DID would look like: did:pkh:mvx:1:erd1....105. Comprehensive Integration ArchitectureThis section provides the detailed technical specification for integrating AP2 and x402 with MultiversX. It outlines the data flow, the mapping of components, and the specific code structures required.5.1 System Roles and MappingThe integration requires mapping the abstract roles of AP2 to concrete MultiversX infrastructure components.Table 2: Role Mapping MatrixAP2 RoleMultiversX ComponentResponsibilityUserMultiversX Account (erd1...)Holds funds; signs Intent Mandates using Ed25519 private key (via xPortal/Ledger).Shopping Agent (SA)Off-chain Logic / Session KeyOrchestrates discovery; requests mandates; constructs inner transaction payloads.Merchant Agent (MA)MultiversX Observer / API ConsumerVerifies on-chain settlement; monitors for incoming payments matching invoices.Credentials Provider (CP)Relayer ServiceActs as the Relayer for V3 transactions; pays gas; manages broadcasting; holds the "Gas Treasury."Payment Railx402 Scheme (mvx)Python module implementing the construction and parsing of MultiversX transactions.5.2 The "Gasless" Agent Payment FlowThe most robust implementation utilizes the Relayed V3 feature to enable seamless agent interaction.Mandate Issuance (Off-Chain):The User signs an Intent Mandate (VC) authorizing the Shopping Agent to spend up to 100 USDC on groceries. The User's DID is did:pkh:mvx:1:erd1user....Negotiation (A2A):The Shopping Agent finds a Merchant. The Merchant requests payment:Message: payment-requiredDetails: { amount: "50000000", currency: "USDC-123456", receiver: "erd1merchant..." }Transaction Construction (Functional Core):The Shopping Agent (or CP) constructs the Inner Transaction:Sender: erd1user...Receiver: erd1merchant...Value: 0 (since it's an ESDT transfer).Data: ESDTTransfer@555344432d313233343536@02f9a... (Hex encoded TokenID and Amount).GasLimit: Calculated based on data length.Authorization (Signing):The User (if present) or the Agent (if authorized via the Intent Mandate and holding a session key) signs this inner transaction.Relaying (Imperative Shell):The Credentials Provider receives the signed inner transaction. It constructs the Relayed V3 Transaction:It adds its own address as Relayer.It adds the gas fee (from its own funds).It signs the RelayerSignature.It broadcasts the final payload to the MultiversX Gateway (POST /transaction/send).Verification:The Merchant Agent polls the Gateway for the transaction hash. Upon success, it releases the goods.5.3 Implementation Specification: The multiversx.py SchemeTo achieve this, a new scheme file must be created in the a2a-x402 repository.File Path: src/x402_a2a/schemes/multiversx.py5.3.1 Class StructureThe Python class must implement the abstract base classes defined in the x402 specification.Pythonfrom x402_a2a.types import PaymentRequest, PaymentDetails, PaymentResult
from multiversx_sdk_core import Transaction, Address, TokenPayment
from multiversx_sdk_core.serializer import json_serializer

class MultiversXScheme:
    """
    Implements the x402 payment scheme for MultiversX (mvx).
    """
    SCHEME_NAME = "mvx"

    def __init__(self, network_config):
        self.chain_id = network_config.get("chain_id", "1") # Default Mainnet
        self.gas_limit_esdt = 500000 # Safety margin

    def create_payment_request(self, amount: int, token_identifier: str, receiver: str) -> PaymentRequest:
        """
        [Functional Core] Generates the 402 Payment Required payload.
        """
        return PaymentRequest(
            scheme=self.SCHEME_NAME,
            network=f"mvx:{self.chain_id}",
            details={
                "receiver": receiver,
                "amount": str(amount),
                "token": token_identifier,
                "data_payload": self._construct_esdt_data(token_identifier, amount)
            }
        )

    def construct_unsigned_transaction(self, request: PaymentRequest, sender: str, nonce: int) -> dict:
        """
        [Functional Core] Creates the inner transaction dictionary for signing.
        """
        details = request.details
        
        tx = Transaction(
            nonce=nonce,
            value="0",
            sender=Address.new_from_bech32(sender),
            receiver=Address.new_from_bech32(details["receiver"]),
            gas_limit=self.gas_limit_esdt, # Should calculate based on data length
            data=details["data_payload"].encode(),
            chain_id=self.chain_id,
            version=2
        )
        
        # Return the dictionary that needs to be serialized and signed
        return tx.to_dictionary()

    def _construct_esdt_data(self, token: str, amount: int) -> str:
        """
        Helper to construct ESDTTransfer data string.
        Format: ESDTTransfer@<TokenHex>@<AmountHex>
        """
        token_hex = token.encode().hex()
        amount_hex = hex(amount)[2:]
        if len(amount_hex) % 2!= 0:
            amount_hex = "0" + amount_hex
        return f"ESDTTransfer@{token_hex}@{amount_hex}"
5.3.2 Verification LogicThe scheme must also include logic to verify a completed payment. This resides in the "Executor" layer but relies on the core for data parsing.Pythondef verify_transaction_content(self, tx_data: dict, request: PaymentRequest) -> bool:
    """
    Verifies that a fetched transaction matches the payment request.
    """
    # 1. Verify Receiver
    if tx_data.get("receiver")!= request.details["receiver"]:
        return False
    
    # 2. Verify Data Field (for ESDT)
    expected_data = request.details["data_payload"]
    # Decode base64 data from API response
    actual_data_base64 = tx_data.get("data", "")
    #... logic to decode base64...
    
    # 3. Verify Status
    if tx_data.get("status")!= "success":
        return False
        
    return True
6. Achieving Official Integration StatusDeveloping the code is only the first step. To achieve "Official Integration," the MultiversX scheme must be accepted into the upstream Google repositories. This requires navigating the open-source governance and contribution landscape.6.1 Governance and Contribution PathwayThe Google Agentic Commerce repositories are open source (Apache 2.0), but they maintain high standards for code quality and security. The path to official integration involves the following steps:6.1.1 Step 1: Standardization (CAIPs)Before submitting code, the underlying standards must be ratified.Action: The MultiversX community or foundation developers must finalize the CAIP-2 namespace definition for mvx. Currently, it may exist as a draft or be used informally. A Pull Request (PR) should be submitted to the ChainAgnostic/namespaces repository to officially register mvx.17Rationale: Google's AP2 library relies on CAIPs for chain-agnosticism. If mvx is not a recognized standard, the integration may be rejected as "proprietary" rather than "standard."6.1.2 Step 2: The Fork and Feature BranchAction: Fork the google-agentic-commerce/a2a-x402 repository.Branching: Create a feature branch named scheme/multiversx or feat/mvx-support. Do not commit directly to main.Structure: Place the scheme implementation in src/x402_a2a/schemes/multiversx.py. This utilizes the repository's existing plugin architecture for new payment rails.126.1.3 Step 3: Comprehensive Testing (The Gatekeeper)Google engineers will not merge code without exhaustive tests.Unit Tests: Create tests/schemes/test_multiversx.py. Use unittest.mock to mock the MultiversX Gateway responses. The tests must verify that create_payment_request returns the correct structure and that construct_unsigned_transaction produces a valid JSON payload matching the MultiversX serialization spec.Integration Tests: Provide a script in examples/multiversx/ that demonstrates a full flow on the MultiversX Devnet.6.1.4 Step 4: Documentation and ExamplesThe PR must include documentation updates.README: Update the main README.md to list MultiversX as a supported scheme.Getting Started: Create a guide docs/multiversx.md explaining how to configure the scheme (e.g., setting MVX_CHAIN_ID, MVX_GATEWAY_URL) and how to install the required Python dependencies (multiversx-sdk-core, multiversx-sdk-wallet).6.1.5 Step 5: The Pull Request (PR)Submit the PR to the google-agentic-commerce/a2a-x402 repository.Title: feat: Add MultiversX (mvx) Payment SchemeDescription: Clearly reference the CAIP-2 standard used. Explain the use of the multiversx-sdk-core library. Highlight the adherence to the "functional core" architecture.Engagement: Actively respond to code review comments. Be prepared to justify design choices, particularly regarding how dependencies are managed (e.g., ensuring they are optional/extras so they don't bloat the core package for non-MultiversX users).7. Security and Compliance ConsiderationsIntegrating an autonomous payment rail brings significant security and compliance challenges that must be addressed in the integration report.7.1 Security: Key Management and SigningThe integration must explicitly forbid the storage of private keys within the a2a-x402 library code.Best Practice: The library should output unsigned transaction payloads.Signing: Signing should be delegated to a secure environment—either a Hardware Security Module (HSM), a dedicated Wallet Service (like the Credentials Provider), or a user's device via WalletConnect. The code provided in the Python scheme must strictly output the "bytes to be signed" and accept the "signature" as input. It should not instantiate a UserSigner with a private key file unless explicitly in a testing context.227.2 Compliance: PCI-DSS and GDPRWhile crypto transactions often bypass traditional PCI-DSS requirements (as there are no credit card PANs), AP2 mandates may contain sensitive data (e.g., shipping addresses in Cart Mandates).GDPR: The integration must ensure that no Personally Identifiable Information (PII) is embedded in the data field of the MultiversX transaction, as the blockchain is immutable. Transaction data should only contain the hash of the Cart Mandate or a generic reference ID. The actual PII stays in the off-chain A2A messages.58. ConclusionThe integration of Google’s AP2 and x402 protocols with MultiversX represents a strategic convergence of Agentic AI and Sovereign Blockchain infrastructure. By combining the rigorous intent authorization of AP2 Mandates with the flexible, gas-abstracted settlement of MultiversX Relayed Transactions V3, developers can build a commerce layer where AI agents operate with both autonomy and accountability.For the integration to be successful and officially recognized, it must be executed with engineering precision—adhering to the "functional core" architecture, respecting W3C and CAIP standards, and following a disciplined open-source contribution strategy. The result will be a "Gasless Agentic" ecosystem where the friction of blockchain mechanics is invisible to the agent, allowing them to focus solely on executing the user's economic intent.9. Appendix: Technical Reference Data9.1 Relayed V3 Transaction JSON SpecificationThis is the required JSON structure for the payment-submitted payload when utilizing the Relayed V3 flow.3JSON{
  "nonce": 15,
  "value": "0", // 0 for ESDT transfer
  "receiver": "erd1merchant_address...",
  "sender": "erd1user_address...",
  "gasPrice": 1000000000,
  "gasLimit": 500000, // Inner gas limit
  "data": "RVNEVFRyYW5zZmVyQDU1NTM0NDQzMmQzMTMyMzM0NTM2QDAx", // Base64: ESDTTransfer@TOKEN@AMOUNT
  "chainID": "1",
  "version": 2,
  "signature": "a7f32c..." // User/Agent signature of the above fields
}
Note: The Credentials Provider (Relayer) will wrap this object, adding relayer and relayerSignature fields before broadcasting to the network.9.2 DID Resolution Table for MultiversXTo verify signatures, the AP2 library must resolve did:pkh identifiers to public keys.Table 3: DID Resolution LogicDID ComponentValueInterpretationResolution ActionSchemedidW3C Standard-MethodpkhPublic Key HashUse CAIP-10 Resolver logicNamespacemvxMultiversXLoad MultiversX address codecChain ID1MainnetUse Mainnet HRP (erd)Account IDerd1...Bech32 AddressDecode Bech32 to 32-byte PubKey9.3 Python Dependency ManifestTo build the official scheme, the pyproject.toml of the a2a-x402 repo should be updated with an optional dependency group:Ini, TOML[project.optional-dependencies]
multiversx = [
    "multiversx-sdk-core>=0.13.0",
    "multiversx-sdk-wallet>=0.11.0",
    "requests>=2.31.0"
]

https://ap2-protocol.org/topics/ap2-and-x402/
https://github.com/google-agentic-commerce
https://github.com/google-agentic-commerce/AP2 
https://github.com/google-agentic-commerce/a2a-x402 
